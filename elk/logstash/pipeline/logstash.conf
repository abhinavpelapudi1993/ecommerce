input {
  beats {
    port => 5044
  }
}

filter {
  if [statusCode] {
    if [statusCode] >= 500 {
      mutate { add_field => { "log_level_category" => "server_error" } }
    } else if [statusCode] >= 400 {
      mutate { add_field => { "log_level_category" => "client_error" } }
    } else {
      mutate { add_field => { "log_level_category" => "success" } }
    }
  }

  date {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
    remove_field => ["timestamp"]
  }

  # Convert responseBody/requestBody to strings to avoid ES mapping conflicts
  # (sometimes they're objects, sometimes strings/arrays)
  ruby {
    code => '
      rb = event.get("responseBody")
      if rb.is_a?(Hash) || rb.is_a?(Array)
        event.set("responseBody", rb.to_json)
      elsif rb
        event.set("responseBody", rb.to_s)
      end
      rq = event.get("requestBody")
      if rq.is_a?(Hash) || rq.is_a?(Array)
        event.set("requestBody", rq.to_json)
      elsif rq
        event.set("requestBody", rq.to_s)
      end
    '
  }

  mutate {
    remove_field => ["agent", "ecs", "host", "input", "log"]
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "ecommerce-logs-%{+YYYY.MM.dd}"
  }
}
